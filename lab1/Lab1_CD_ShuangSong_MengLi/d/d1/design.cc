//////////////////////////////////////////////////////////////////////
// C++ source file generated by SpecC V2.2.1
// Design: design
// File:   design.cc
// Time:   Sat Sep 26 17:39:16 2015
//////////////////////////////////////////////////////////////////////

// Note: User-defined include files are inlined in this file.

// Note: System-defined include files are inlined in this file.

#include "design.h"


unsigned int _IDcnt = 0;
// channel class definitions /////////////////////////////////////////

c_r_queue::c_r_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_r_queue::~c_r_queue(void)
{   /* nothing */
}

#line 6 "./c_type_define.sc"
void c_r_queue::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 6 "./c_type_define.sc"
void c_r_queue::receive(int *d) { while( !n) { wr++ ; _specc::wait(event(&r), ((void*)0)); wr-- ;
    }

#line 6 "./c_type_define.sc"
    if (n <= p) {  *d = buffer[p - n];
    }
    else 

#line 6 "./c_type_define.sc"
    {     *d = buffer[p + size - n];
    }

#line 6 "./c_type_define.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 6 "./c_type_define.sc"
    cleanup();
}

#line 6 "./c_type_define.sc"
void c_r_queue::send(int d) { while(n >= size) { ws++ ; _specc::wait(event(&s), ((void*)0)); ws-- ;
    }

#line 6 "./c_type_define.sc"
    setup(); buffer[p] = d; p++ ; if (p >= size) { p = 0;
    }

#line 6 "./c_type_define.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 6 "./c_type_define.sc"
void c_r_queue::setup(void) { if ( !buffer) { int dummy; unsigned long int i; if ( !(buffer = (int *)malloc(sizeof(int) * size))) { perror("c_typed_queue"); abort();
	}

#line 6 "./c_type_define.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(int));
	}
    }
}

#line 82 "design.cc"
c_mid_queue::c_mid_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_mid_queue::~c_mid_queue(void)
{   /* nothing */
}

#line 11 "./c_type_define.sc"
void c_mid_queue::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 11 "./c_type_define.sc"
void c_mid_queue::receive(unsigned char *d) { while( !n) { wr++ ; _specc::wait(event(&r), ((void*)0)); wr-- ;
    }

#line 11 "./c_type_define.sc"
    if (n <= p) {  *d = buffer[p - n];
    }
    else 

#line 11 "./c_type_define.sc"
    {     *d = buffer[p + size - n];
    }

#line 11 "./c_type_define.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 11 "./c_type_define.sc"
    cleanup();
}

#line 11 "./c_type_define.sc"
void c_mid_queue::send(unsigned char d) { while(n >= size) { ws++ ; _specc::wait(event(&s), ((void*)0)); ws-- ;
    }

#line 11 "./c_type_define.sc"
    setup(); buffer[p] = d; p++ ; if (p >= size) { p = 0;
    }

#line 11 "./c_type_define.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 11 "./c_type_define.sc"
void c_mid_queue::setup(void) { if ( !buffer) { unsigned char dummy; unsigned long int i; if ( !(buffer = (unsigned char *)malloc(sizeof(unsigned char) * size))) { perror("c_typed_queue"); abort();
	}

#line 11 "./c_type_define.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(unsigned char));
	}
    }
}

#line 146 "design.cc"
c_in_queue::c_in_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_in_queue::~c_in_queue(void)
{   /* nothing */
}

#line 17 "./c_type_define.sc"
void c_in_queue::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 17 "./c_type_define.sc"
void c_in_queue::receive(unsigned char *d) { while( !n) { wr++ ; _specc::wait(event(&r), ((void*)0)); wr-- ;
    }

#line 17 "./c_type_define.sc"
    if (n <= p) {  *d = buffer[p - n];
    }
    else 

#line 17 "./c_type_define.sc"
    {     *d = buffer[p + size - n];
    }

#line 17 "./c_type_define.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 17 "./c_type_define.sc"
    cleanup();
}

#line 17 "./c_type_define.sc"
void c_in_queue::send(unsigned char d) { while(n >= size) { ws++ ; _specc::wait(event(&s), ((void*)0)); ws-- ;
    }

#line 17 "./c_type_define.sc"
    setup(); buffer[p] = d; p++ ; if (p >= size) { p = 0;
    }

#line 17 "./c_type_define.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 17 "./c_type_define.sc"
void c_in_queue::setup(void) { if ( !buffer) { unsigned char dummy; unsigned long int i; if ( !(buffer = (unsigned char *)malloc(sizeof(unsigned char) * size))) { perror("c_typed_queue"); abort();
	}

#line 17 "./c_type_define.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(unsigned char));
	}
    }
}

#line 210 "design.cc"
c_double_handshake::c_double_handshake()
    : _specc::channel(),
    v(false),
    w(false)
{   /* nothing */
}

c_double_handshake::~c_double_handshake(void)
{   /* nothing */
}

#line 81 "c_double_handshake.sc"
void c_double_handshake::receive(void *d, unsigned long int l)
{   
    if ( !v)
    {   
	w = true;
	_specc::wait(event(&req), ((void*)0));
	w = false;
    }
    if (l != tmpl)
    {   
	abort();
    }
    memcpy(d, tmpd, l);
    v = false;
    _specc::notify(event(&ack), ((void*)0));
    _specc::wait(event(&ack), ((void*)0));
}

void c_double_handshake::send(const void *d, unsigned long int l)
{   
    tmpd = d;
    tmpl = l;
    v = true;
    if (w)
    {   
	_specc::notify(event(&req), ((void*)0));
    }
    _specc::wait(event(&ack), ((void*)0));
}

#line 253 "design.cc"
c_queue::c_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_queue::~c_queue(void)
{   /* nothing */
}

#line 99 "c_queue.sc"
void c_queue::cleanup(void)
{   
    if ( !n)
    {   
	free(buffer);
	buffer = 0;
    }
}

void c_queue::receive(void *d, unsigned long int l)
{   
    unsigned long int p0;

    while(l > n)
    {   
	wr++ ;
	_specc::wait(event(&r), ((void*)0));
	wr-- ;
    }

    if (n <= p)
    {   
	p0 = p - n;
    }
    else 
    {   
	p0 = p + size - n;
    }
    if (l <= size - p0)
    {   
	memcpy(d,  &buffer[p0], l);
	n -= l;
    }
    else 
    {   
	memcpy(d,  &buffer[p0], size - p0);
	memcpy(((char *)d) + (size - p0),  &buffer[0], l - (size - p0));
	n -= l;
    }

    if (ws)
    {   
	_specc::notify(event(&s), ((void*)0));
    }

    cleanup();
}

void c_queue::send(const void *d, unsigned long int l)
{   
    while(l > size - n)
    {   
	ws++ ;
	_specc::wait(event(&s), ((void*)0));
	ws-- ;
    }

    setup();

    if (l <= size - p)
    {   
	memcpy( &buffer[p], d, l);
	p += l;
	n += l;
    }
    else 
    {   
	memcpy( &buffer[p], d, size - p);
	memcpy( &buffer[0], ((char *)d) + (size - p), l - (size - p));
	p = l - (size - p);
	n += l;
    }

    if (wr)
    {   
	_specc::notify(event(&r), ((void*)0));
    }
}

#line 87 "c_queue.sc"
void c_queue::setup(void)
{   
    if ( !buffer)
    {   
	if ( !(buffer = (char *)malloc(size)))
	{   
	    perror("c_queue");
	    abort();
	}
    }
}

// behavior class definitions ////////////////////////////////////////

#line 363 "design.cc"
cal_mid_thread::cal_mid_thread(unsigned int _idcnt, unsigned char (&mid)[7220], unsigned char (&in_sc)[7220], unsigned char (&bp)[516], int (&r)[7220], int (&sp), int (&ep), int (&max_no))
    : _specc::behavior(_idcnt), mid(mid), in_sc(in_sc), bp(bp), r(r), sp(sp), ep(ep), max_no(max_no)
{   /* nothing */
}

cal_mid_thread::~cal_mid_thread(void)
{   /* nothing */
}

#line 27 "./DetectEdges.sc"
int cal_mid_thread::cir_mask(unsigned char cir_in[7220], unsigned char cir_bp[516], int i, int j, int sel) {
    int n = 0;
    unsigned char *cp;

    int ci = 3;
    int cj = 3;
    int i_d = 0; int j_d = 0;

    int c;

    int mask[7][7] = { { 0,0,1,1,1,0,0 },{ 
	0,1,1,1,1,1,0 },{ 
	1,1,1,1,1,1,1 },{ 
	1,1,1,0,1,1,1 },{ 
	1,1,1,1,1,1,1 },{ 
	0,1,1,1,1,1,0 },{ 
	0,0,1,1,1,0,0 } };



    cp = cir_bp + cir_in[i * 76 + j] + 258;

    for(i_d =  -3; i_d <= 3; i_d++ ) {
	for(j_d =  -3; j_d <= 3; j_d++ ) {
	    if (mask[ci + i_d][cj + j_d] == 1) {
		c = (unsigned int) *(cp - cir_in[(i + i_d) * 76 + j + j_d]);
		if (sel == 0) {
		    n = n + c;
		}
		else  if (sel == 1) {
			n = n + j_d * c;
		    }
		    else  if (sel == 2) {
			    n = n + i_d * c;
			}
			else  if (sel == 3) {
				n = n + j_d * j_d * c;
			    }
			    else  if (sel == 4) {
				    n = n + i_d * i_d * c;
				}
				else  if (sel == 5) {
					n = n + i_d * j_d * c;
				    }
	    }
	}
    }

    switch(sel) {
	case 0: return (n + 100);
	case 1:
	    case 2:
		case 3:
		    case 4:
			case 5: return n;
	default: return n;
    }
}

void cal_mid_thread::main(void) {
    float z;
    int a; int b; int do_symmetry; int i; int j; int m; int n; int w; int x; int y;

    for(i = 4; i < 95 - 4; i++ ) {
	for(j = sp; j < ep; j++ ) {
	    if (r[i * 76 + j] <= 0)
		continue;
	    m = r[i * 76 + j];
	    n = max_no - m;
	    if (n > 600) {
		x = cir_mask(in_sc, bp, i, j, 1);
		y = cir_mask(in_sc, bp, i, j, 2);
		z = sqrt((float)((x * x) + (y * y)));
		if (z > (9.000000000000000e-01 * (float)n)) {
		    do_symmetry = 0;
		    if (x == 0)
			z = 1.000000000000000e+06;
		    else 
			z = ((float)y) / ((float)x);
		    if (z < 0) { z =  -z; w =  -1;
		    }
		    else 

#line 107 "./DetectEdges.sc"
			w = 1;
		    if (z < 5.000000000000000e-01) { a = 0; b = 1;
		    }
		    else 

#line 109 "./DetectEdges.sc"
		    {   
			if (z > 2.000000000000000e+00) { a = 1; b = 0;
			}
			else 

#line 111 "./DetectEdges.sc"
			{   
			    if (w > 0) { a = 1; b = 1;
			    }
			    else 

#line 113 "./DetectEdges.sc"
			    {    a =  -1; b = 1;
			    }
			}
		    } if ((m > r[(i + a) * 76 + j + b]) && (m >= r[(i - a) * 76 + j - b]) && (m > r[(i + (2 * a)) * 76 + j + (2 * b)]) && (m >= r[(i - (2 * a)) * 76 + j - (2 * b)]))
			mid[i * 76 + j] = 1;
		}
		else 
		    do_symmetry = 1;
	    }
	    else 
		do_symmetry = 1;

	    if (do_symmetry == 1) {
		x = cir_mask(in_sc, bp, i, j, 3);
		y = cir_mask(in_sc, bp, i, j, 4);
		w = cir_mask(in_sc, bp, i, j, 5);
		if (y == 0)
		    z = 1.000000000000000e+06;
		else 
		    z = ((float)x) / ((float)y);

		if (z < 5.000000000000000e-01) { a = 0; b = 1;
		}
		else 

#line 135 "./DetectEdges.sc"
		{   
		    if (z > 2.000000000000000e+00) { a = 1; b = 0;
		    }
		    else 

#line 137 "./DetectEdges.sc"
		    {   
			if (w > 0) { a =  -1; b = 1;
			}
			else 

#line 139 "./DetectEdges.sc"
			{    a = 1; b = 1;
			}
		    }
		} if ((m > r[(i + a) * 76 + j + b]) && (m >= r[(i - a) * 76 + j - b]) && (m > r[(i + (2 * a)) * 76 + j + (2 * b)]) && (m >= r[(i - (2 * a)) * 76 + j - (2 * b)]))
		    mid[i * 76 + j] = 2;
	    }
	}
    }
}

#line 524 "design.cc"
cal_r_thread::cal_r_thread(unsigned int _idcnt, int (&r)[7220], unsigned char (&in_sc)[7220], unsigned char (&bp)[516], int (&row_start), int (&row_end), int (&max_no))
    : _specc::behavior(_idcnt), r(r), in_sc(in_sc), bp(bp), row_start(row_start), row_end(row_end), max_no(max_no)
{   /* nothing */
}

cal_r_thread::~cal_r_thread(void)
{   /* nothing */
}

#line 165 "./DetectEdges.sc"
int cal_r_thread::cir_mask(unsigned char cir_in[7220], unsigned char cir_bp[516], int i, int j, int sel) {
    int n = 0;
    unsigned char *cp;

    int ci = 3;
    int cj = 3;
    int i_d = 0; int j_d = 0;

    int c;

    int mask[7][7] = { { 0,0,1,1,1,0,0 },{ 
	0,1,1,1,1,1,0 },{ 
	1,1,1,1,1,1,1 },{ 
	1,1,1,0,1,1,1 },{ 
	1,1,1,1,1,1,1 },{ 
	0,1,1,1,1,1,0 },{ 
	0,0,1,1,1,0,0 } };



    cp = cir_bp + cir_in[i * 76 + j] + 258;

    for(i_d =  -3; i_d <= 3; i_d++ ) {
	for(j_d =  -3; j_d <= 3; j_d++ ) {
	    if (mask[ci + i_d][cj + j_d] == 1) {
		c = (unsigned int) *(cp - cir_in[(i + i_d) * 76 + j + j_d]);

		if (sel == 0) {
		    n = n + c;
		}
		else 
		    if (sel == 1) {
			n = n + j_d * c;
		    }
		    else  if (sel == 2) {
			    n = n + i_d * c;
			}
			else  if (sel == 3) {
				n = n + j_d * j_d * c;
			    }
			    else 
				if (sel == 4) {
				    n = n + i_d * i_d * c;
				}
				else  if (sel == 5) {
					n = n + i_d * j_d * c;
				    }
	    }
	}
    }


    switch(sel) {
	case 0: return (n + 100);
	case 1:
	    case 2:
		case 3:
		    case 4:
			case 5: return n;
	default: return n;
    }
}

void cal_r_thread::main(void) {

    int i = 0; int j = 0; int n = 0;
    for(i = 3; i < 95 - 3; i++ ) {
	for(j = row_start; j < row_end; j++ ) {
	    n = cir_mask(in_sc, bp, i, j, 0);
	    if (n <= max_no) {
		r[i * 76 + j] = max_no - n;
	    }
	}
    }
}

#line 611 "design.cc"
SusanEdges::SusanEdges(unsigned int _idcnt, unsigned char (&in_sc)[7220], int (&r)[7220], unsigned char (&mid)[7220], unsigned char (&bp)[516])
    : _specc::behavior(_idcnt), in_sc(in_sc), r(r), mid(mid), bp(bp),
    max_no(2650),
    row_sep(38),
    x_end(73),
    x_end_2(72),
    _scc_const_port_0(4),
    _scc_const_port_1(3),
    cal_mid_thread1(_IDcnt, mid_thread1, in_sc, bp, r, _scc_const_port_0, row_sep, max_no),
    cal_mid_thread2(_IDcnt, mid_thread2, in_sc, bp, r, row_sep, x_end_2, max_no),
    cal_r_thread1(_IDcnt, r_thread1, in_sc, bp, _scc_const_port_1, row_sep, max_no),
    cal_r_thread2(_IDcnt, r_thread2, in_sc, bp, row_sep, x_end, max_no)
{   /* nothing */
}

SusanEdges::~SusanEdges(void)
{   /* nothing */
}

#line 265 "./DetectEdges.sc"
void SusanEdges::main(void)
{   


    int i; int j;

#line 277 "./DetectEdges.sc"
    for(i = 0; i < 95; i++ ) {
	for(j = 0; j < 76; j++ ) {
	    mid[i * 76 + j] = 100;
	    mid_thread1[i * 76 + j] = 100;
	    mid_thread2[i * 76 + j] = 100;
	}
    }

    for(i = 0; i < 95; i++ ) {
	for(j = 0; j < 76; j++ ) {
	    r[i * 76 + j] = 0;
	    r_thread1[i * 76 + j] = 0;
	    r_thread2[i * 76 + j] = 0;
	}
    }



    { _specc::fork _scc_fork_0(&cal_r_thread1), _scc_fork_1(&cal_r_thread2); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, ((_specc::fork*)0));
    }

    for(i = 3; i < 95 - 3; i++ ) {
	for(j = 3; j < 76 - 3; j++ ) {
	    if (j < row_sep)
		r[i * 76 + j] = r_thread1[i * 76 + j];
	    else 
		r[i * 76 + j] = r_thread2[i * 76 + j];
	}
    }

#line 314 "./DetectEdges.sc"
    { _specc::fork _scc_fork_0(&cal_mid_thread1), _scc_fork_1(&cal_mid_thread2); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, ((_specc::fork*)0));
    }

    for(i = 4; i < 95 - 4; i++ ) {
	for(j = 4; j < 76 - 4; j++ ) {
	    if (j < row_sep)
		mid[i * 76 + j] = mid_thread1[i * 76 + j];
	    else 
		mid[i * 76 + j] = mid_thread2[i * 76 + j];
	}
    }
}

#line 687 "design.cc"
SetupBrightnessLut::SetupBrightnessLut(unsigned int _idcnt, unsigned char (&bp)[516])
    : _specc::behavior(_idcnt), bp(bp),
    thresh(20)
{   /* nothing */
}

SetupBrightnessLut::~SetupBrightnessLut(void)
{   /* nothing */
}

#line 338 "./DetectEdges.sc"
void SetupBrightnessLut::main(void)
{   

    int k;
    float temp;

#line 348 "./DetectEdges.sc"
    for(k =  -256; k < 257; k++ )
    {   
	temp = ((float)k) / ((float)thresh);
	temp = temp * temp;
	temp = temp * temp * temp;
	temp = 1.000000000000000e+02 * exp( -temp);
	 *(bp + 258 + k) = (unsigned char)temp;
    }
}

#line 716 "design.cc"
DetectEdges::DetectEdges(unsigned int _idcnt, i_in_receiver (&in_buffer), i_r_sender (&r_s), i_mid_sender (&mid_s))
    : _specc::behavior(_idcnt), in_buffer(in_buffer), r_s(r_s), mid_s(mid_s),
    Edge(_IDcnt, in_sc, r, mid, bp),
    SBLut(_IDcnt, bp)
{   /* nothing */
}

DetectEdges::~DetectEdges(void)
{   /* nothing */
}

#line 375 "./DetectEdges.sc"
void DetectEdges::main(void)
{   

    int i = 0;

    for(i = 0; i < 7220; i++ )
	in_buffer.receive(in_sc + i);



    SBLut.main();
    Edge.main();



    for(i = 0; i < 7220; i++ ) {
	r_s.send(r[i]);
	mid_s.send(mid[i]);
    }
}

#line 750 "design.cc"
EdgeDraw::EdgeDraw(unsigned int _idcnt, i_in_receiver (&in_buffer), i_mid_receiver (&mid_r), int (&drawing_mode), i_in_sender (&sd))
    : _specc::behavior(_idcnt), in_buffer(in_buffer), mid_r(mid_r), drawing_mode(drawing_mode), sd(sd)
{   /* nothing */
}

EdgeDraw::~EdgeDraw(void)
{   /* nothing */
}

#line 22 "./EdgeDraw.sc"
void EdgeDraw::main(void)
{   

    int i;
    unsigned char *inp; unsigned char *midp;

    for(i = 0; i < 7220; i++ )
	in_buffer.receive(in_sc + i);

    for(i = 0; i < 7220; i++ )
	mid_r.receive(mid + i);

    if (drawing_mode == 0)
    {   

	midp = mid;
	for(i = 0; i < 76 * 95; i++ )
	{   
	    if ( *midp < 8)
	    {   
		inp = in_sc + (midp - mid) - 76 - 1;
		 *inp++  = 255;  *inp++  = 255;  *inp = 255; inp += 76 - 2;
		 *inp++  = 255;  *inp++ ;  *inp = 255; inp += 76 - 2;
		 *inp++  = 255;  *inp++  = 255;  *inp = 255;
	    }
	    midp++ ;
	}
    }


    midp = mid;
    for(i = 0; i < 76 * 95; i++ )
    {   
	if ( *midp < 8)
	     *(in_sc + (midp - mid)) = 0;
	midp++ ;
    }

    for(i = 0; i < 7220; i++ )
	sd.send( *(in_sc + i));
}

#line 803 "design.cc"
SusanThin::SusanThin(unsigned int _idcnt, i_r_receiver (&r_r), i_mid_receiver (&mid_r), i_mid_sender (&mid_s))
    : _specc::behavior(_idcnt), r_r(r_r), mid_r(mid_r), mid_s(mid_s)
{   /* nothing */
}

SusanThin::~SusanThin(void)
{   /* nothing */
}

#line 19 "./SusanThin.sc"
void SusanThin::main(void)
{   

    int a; int b; int b00; int b01; int b02; int b10; int b12; int b20; int b21; int b22; int centre; int i; int j; int l[9]; int m; int n; int p1; int p2; int p3; int p4; int x; int y;
    unsigned char *mp;

    for(i = 0; i < 7220; i++ )
	r_r.receive(r + i);

    for(i = 0; i < 7220; i++ )
	mid_r.receive(mid + i);

    for(i = 4; i < 95 - 4; i++ )
	for(j = 4; j < 76 - 4; j++ )
	    if (mid[i * 76 + j] < 8)
	    {   
		centre = r[i * 76 + j];


		mp = mid + (i - 1) * 76 + j - 1;
		n = ( *mp < 8) + 
		( *(mp + 1) < 8) + 
		( *(mp + 2) < 8) + 
		( *(mp + 76) < 8) + 
		( *(mp + 76 + 2) < 8) + 
		( *(mp + 76 + 76) < 8) + 
		( *(mp + 76 + 76 + 1) < 8) + 
		( *(mp + 76 + 76 + 2) < 8);




		if (n == 0)
		    mid[i * 76 + j] = 100;

#line 59 "./SusanThin.sc"
		if ((n == 1) && (mid[i * 76 + j] < 6))
		{   

#line 67 "./SusanThin.sc"
		    l[0] = r[(i - 1) * 76 + j - 1];
		    l[1] = r[(i - 1) * 76 + j];
		    l[2] = r[(i - 1) * 76 + j + 1];
		    l[3] = r[(i) * 76 + j - 1];
		    l[4] = 0;
		    l[5] = r[(i) * 76 + j + 1];
		    l[6] = r[(i + 1) * 76 + j - 1];
		    l[7] = r[(i + 1) * 76 + j];
		    l[8] = r[(i + 1) * 76 + j + 1];

		    if (mid[(i - 1) * 76 + j - 1] < 8) { l[0] = 0; l[1] = 0; l[3] = 0; l[2] *= 2;
			l[6] *= 2; l[5] *= 3; l[7] *= 3; l[8] *= 4;
		    }
		    else 

#line 79 "./SusanThin.sc"
		    {    if (mid[(i - 1) * 76 + j] < 8) { l[1] = 0; l[0] = 0; l[2] = 0; l[3] *= 2;
			    l[5] *= 2; l[6] *= 3; l[8] *= 3; l[7] *= 4;
			}
			else 

#line 81 "./SusanThin.sc"
			{    if (mid[(i - 1) * 76 + j + 1] < 8) { l[2] = 0; l[1] = 0; l[5] = 0; l[0] *= 2;
				l[8] *= 2; l[3] *= 3; l[7] *= 3; l[6] *= 4;
			    }
			    else 

#line 83 "./SusanThin.sc"
			    {    if (mid[(i) * 76 + j - 1] < 8) { l[3] = 0; l[0] = 0; l[6] = 0; l[1] *= 2;
				    l[7] *= 2; l[2] *= 3; l[8] *= 3; l[5] *= 4;
				}
				else 

#line 85 "./SusanThin.sc"
				{    if (mid[(i) * 76 + j + 1] < 8) { l[5] = 0; l[2] = 0; l[8] = 0; l[1] *= 2;
					l[7] *= 2; l[0] *= 3; l[6] *= 3; l[3] *= 4;
				    }
				    else 

#line 87 "./SusanThin.sc"
				    {    if (mid[(i + 1) * 76 + j - 1] < 8) { l[6] = 0; l[3] = 0; l[7] = 0; l[0] *= 2;
					    l[8] *= 2; l[1] *= 3; l[5] *= 3; l[2] *= 4;
					}
					else 

#line 89 "./SusanThin.sc"
					{    if (mid[(i + 1) * 76 + j] < 8) { l[7] = 0; l[6] = 0; l[8] = 0; l[3] *= 2;
						l[5] *= 2; l[0] *= 3; l[2] *= 3; l[1] *= 4;
					    }
					    else 

#line 91 "./SusanThin.sc"
					    {    if (mid[(i + 1) * 76 + j + 1] < 8) { l[8] = 0; l[5] = 0; l[7] = 0; l[6] *= 2;
						    l[2] *= 2; l[1] *= 3; l[3] *= 3; l[0] *= 4;
						}
					    }
					}
				    }
				}
			    }
			}
		    }

#line 94 "./SusanThin.sc"
		    m = 0;
		    for(y = 0; y < 3; y++ )
			for(x = 0; x < 3; x++ )
			    if (l[y + y + y + x] > m) { m = l[y + y + y + x]; a = y; b = x;
			    }
		    if (m > 0)
		    {   
			if (mid[i * 76 + j] < 4)
			    mid[(i + a - 1) * 76 + j + b - 1] = 4;
			else 
			    mid[(i + a - 1) * 76 + j + b - 1] = mid[i * 76 + j] + 1;
			if ((a + a + b) < 3)
			{   
			    i += a - 1;
			    j += b - 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}



		if (n == 2)
		{   

		    b00 = mid[(i - 1) * 76 + j - 1] < 8;
		    b02 = mid[(i - 1) * 76 + j + 1] < 8;
		    b20 = mid[(i + 1) * 76 + j - 1] < 8;
		    b22 = mid[(i + 1) * 76 + j + 1] < 8;
		    if (((b00 + b02 + b20 + b22) == 2) && ((b00 | b22) & (b02 | b20)))
		    {   



			if (b00)
			{   
			    if (b02) { x = 0; y =  -1;
			    }
			    else 

#line 132 "./SusanThin.sc"
			    {    x =  -1; y = 0;
			    }
			}
			else  {
			    if (b02) { x = 1; y = 0;
			    }
			    else 

#line 137 "./SusanThin.sc"
			    {    x = 0; y = 1;
			    }
			} if (((float)r[(i + y) * 76 + j + x] / (float)centre) > 7.000000000000000e-01)
			{   
			    if (((x == 0) && (mid[(i + (2 * y)) * 76 + j] > 7) && (mid[(i + (2 * y)) * 76 + j - 1] > 7) && (mid[(i + (2 * y)) * 76 + j + 1] > 7)) || ((y == 0) && (mid[(i) * 76 + j + (2 * x)] > 7) && (mid[(i + 1) * 76 + j + (2 * x)] > 7) && (mid[(i - 1) * 76 + j + (2 * x)] > 7)))
			    {   
				mid[(i) * 76 + j] = 100;
				mid[(i + y) * 76 + j + x] = 3;
			    }
			}
		    }
		    else 
		    {   
			b01 = mid[(i - 1) * 76 + j] < 8;
			b12 = mid[(i) * 76 + j + 1] < 8;
			b21 = mid[(i + 1) * 76 + j] < 8;
			b10 = mid[(i) * 76 + j - 1] < 8;



			if (((b01 + b12 + b21 + b10) == 2) && ((b10 | b12) & (b01 | b21)) && ((b01 & ((mid[(i - 2) * 76 + j - 1] < 8) | (mid[(i - 2) * 76 + j + 1] < 8))) | (b10 & ((mid[(i - 1) * 76 + j - 2] < 8) | (mid[(i + 1) * 76 + j - 2] < 8))) | (b12 & ((mid[(i - 1) * 76 + j + 2] < 8) | (mid[(i + 1) * 76 + j + 2] < 8))) | (b21 & ((mid[(i + 2) * 76 + j - 1] < 8) | (mid[(i + 2) * 76 + j + 1] < 8)))))
			{   



			    mid[(i) * 76 + j] = 100;
			    i-- ;
			    j -= 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}


		if (n > 2)
		{   
		    b01 = mid[(i - 1) * 76 + j] < 8;
		    b12 = mid[(i) * 76 + j + 1] < 8;
		    b21 = mid[(i + 1) * 76 + j] < 8;
		    b10 = mid[(i) * 76 + j - 1] < 8;
		    if ((b01 + b12 + b21 + b10) > 1)
		    {   
			b00 = mid[(i - 1) * 76 + j - 1] < 8;
			b02 = mid[(i - 1) * 76 + j + 1] < 8;
			b20 = mid[(i + 1) * 76 + j - 1] < 8;
			b22 = mid[(i + 1) * 76 + j + 1] < 8;
			p1 = b00 | b01;
			p2 = b02 | b12;
			p3 = b22 | b21;
			p4 = b20 | b10;

			if (((p1 + p2 + p3 + p4) - ((b01 & p2) + (b12 & p3) + (b21 & p4) + (b10 & p1))) < 2)
			{   
			    mid[(i) * 76 + j] = 100;
			    i-- ;
			    j -= 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}
	    }


    for(i = 0; i < 7220; i++ )
	mid_s.send( *(mid + i));
}

#line 1038 "design.cc"
get_image::get_image(unsigned int _idcnt, i_sender (&start), unsigned char (&in_sc)[7220], char (&filename)[200])
    : _specc::behavior(_idcnt), start(start), in_sc(in_sc), filename(filename)
{   /* nothing */
}

get_image::~get_image(void)
{   /* nothing */
}

#line 19 "./get_image.sc"
int get_image::getint(struct _IO_FILE *fd)
{   
    int c; int i;
    char dummy[10000];

    c = _IO_getc(fd);
    while(1)
    {   
	if (c == '#')
	    fgets(dummy, 9000, fd);
	if (c == ( -1))
	{    fprintf(stderr, "Image %s not binary PGM.\n", "is"); exit(0);
	}

#line 30 "./get_image.sc"
	;
	if (c >= '0' && c <= '9')
	    break;
	c = _IO_getc(fd);
    }


    i = 0;
    while(1) {
	i = (i * 10) + (c - '0');
	c = _IO_getc(fd);
	if (c == ( -1)) return (i);
	if (c < '0' || c > '9') break;
    }

    return (i);
}

void get_image::main(void)
{   
    struct _IO_FILE *fd;
    char header[100];
    int tmp;
    int handshake = 0;

    char buf_start[21];


    if ((fd = fopen(filename, "r")) == ((void *)0))
    {    fprintf(stderr, "Can't input image %s.\n", filename); exit(0);
    }

#line 59 "./get_image.sc"
    ;




    header[0] = fgetc(fd);
    header[1] = fgetc(fd);

    if ( !(header[0] == 'P' && header[1] == '5'))
    {    fprintf(stderr, "Image %s does not have binary PGM header.\n", filename); exit(0);
    }

#line 68 "./get_image.sc"
    ;

    tmp = getint(fd);
    tmp = getint(fd);
    tmp = getint(fd);

    if (fread(in_sc, 1, 76 * 95, fd) == 0)
    {    fprintf(stderr, "Image %s is wrong size.\n", filename); exit(0);
    }

#line 75 "./get_image.sc"
    ;

    fclose(fd);




    printf("Time %4s: start sending images\n", time2str(buf_start, now()));


    start.send( &handshake, sizeof(unsigned int));
}

#line 1134 "design.cc"
put_image::put_image(unsigned int _idcnt, i_receiver (&rec), char (&filename)[200])
    : _specc::behavior(_idcnt), rec(rec), filename(filename)
{   /* nothing */
}

put_image::~put_image(void)
{   /* nothing */
}

#line 25 "./put_image.sc"
void put_image::main(void)
{   
    struct _IO_FILE *fd;
    rec.receive(out_sc, 76 * 95 * sizeof(unsigned char));

    printf("Put image: Time is now %s pico sec. \n", time2str(buffer, now()));




    if ((fd = fopen(filename, "w")) == ((void *)0))
    {    fprintf(stderr, "Can't output image%s.\n", filename); exit(0);
    }

#line 36 "./put_image.sc"
    ;

    fprintf(fd, "P5\n");
    fprintf(fd, "%d %d\n", 76, 95);
    fprintf(fd, "255\n");

    if (fwrite(out_sc, 76 * 95, 1, fd) != 1)
    {    fprintf(stderr, "Can't write image %s.\n", filename); exit(0);
    }

#line 43 "./put_image.sc"
    ;

    fclose(fd);
}

#line 1176 "design.cc"
rprocess::rprocess(unsigned int _idcnt, i_receiver (&start), unsigned char (&in_sc)[7220], i_in_sender (&sd), i_in_sender (&se))
    : _specc::behavior(_idcnt), start(start), in_sc(in_sc), sd(sd), se(se)
{   /* nothing */
}

rprocess::~rprocess(void)
{   /* nothing */
}

#line 19 "./read_image.sc"
void rprocess::main(void) {
    int handshake = 0;
    int i;
    start.receive( &handshake, sizeof(unsigned int));

    for(i = 0; i < 7220; i++ ) {
	sd.send(in_sc[i]);
	se.send(in_sc[i]);
    }
}

#line 1198 "design.cc"
ReadImage::ReadImage(unsigned int _idcnt, i_receiver (&start), unsigned char (&in_sc)[7220], i_in_sender (&sd), i_in_sender (&se))
    : _specc::behavior(_idcnt), start(start), in_sc(in_sc), sd(sd), se(se),
    r(_IDcnt, start, in_sc, sd, se)
{   /* nothing */
}

ReadImage::~ReadImage(void)
{   /* nothing */
}

#line 37 "./read_image.sc"
void ReadImage::main(void) {
    { enum { _scc_state_0, _scc_state_r } _scc_next_state = _scc_state_r; do switch(_scc_next_state) {
	    case _scc_state_r: { r.main(); { _scc_next_state = _scc_state_r; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1216 "design.cc"
DetectEdges_wp::DetectEdges_wp(unsigned int _idcnt, i_in_receiver (&in_buffer), i_r_sender (&r_s), i_mid_sender (&mid_s))
    : _specc::behavior(_idcnt), in_buffer(in_buffer), r_s(r_s), mid_s(mid_s),
    D(_IDcnt, in_buffer, r_s, mid_s)
{   /* nothing */
}

DetectEdges_wp::~DetectEdges_wp(void)
{   /* nothing */
}

#line 34 "./susan.sc"
void DetectEdges_wp::main(void) {
    { enum { _scc_state_0, _scc_state_D } _scc_next_state = _scc_state_D; do switch(_scc_next_state) {
	    case _scc_state_D: { D.main(); { _scc_next_state = _scc_state_D; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1234 "design.cc"
SusanThin_wp::SusanThin_wp(unsigned int _idcnt, i_r_receiver (&r_r), i_mid_receiver (&mid_r), i_mid_sender (&mid_s))
    : _specc::behavior(_idcnt), r_r(r_r), mid_r(mid_r), mid_s(mid_s),
    S(_IDcnt, r_r, mid_r, mid_s)
{   /* nothing */
}

SusanThin_wp::~SusanThin_wp(void)
{   /* nothing */
}

#line 49 "./susan.sc"
void SusanThin_wp::main(void) {

    { enum { _scc_state_0, _scc_state_S } _scc_next_state = _scc_state_S; do switch(_scc_next_state) {
	    case _scc_state_S: { S.main(); { _scc_next_state = _scc_state_S; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1253 "design.cc"
EdgeDraw_wp::EdgeDraw_wp(unsigned int _idcnt, i_in_receiver (&in_buffer), i_mid_receiver (&mid_r), i_in_sender (&sd))
    : _specc::behavior(_idcnt), in_buffer(in_buffer), mid_r(mid_r), sd(sd),
    _scc_const_port_0(0),
    E(_IDcnt, in_buffer, mid_r, _scc_const_port_0, sd)
{   /* nothing */
}

EdgeDraw_wp::~EdgeDraw_wp(void)
{   /* nothing */
}

#line 69 "./susan.sc"
void EdgeDraw_wp::main(void) {

    { enum { _scc_state_0, _scc_state_E } _scc_next_state = _scc_state_E; do switch(_scc_next_state) {
	    case _scc_state_E: { E.main(); { _scc_next_state = _scc_state_E; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1273 "design.cc"
susan::susan(unsigned int _idcnt, i_in_receiver (&buffer_in_d), i_in_receiver (&buffer_in_e), i_in_sender (&buffer_out))
    : _specc::behavior(_idcnt), buffer_in_d(buffer_in_d), buffer_in_e(buffer_in_e), buffer_out(buffer_out),
    q_len(7220ul),
    D(++_IDcnt, buffer_in_d, rq, mq),
    E(++_IDcnt, buffer_in_e, mq2, buffer_out),
    S(++_IDcnt, rq, mq, mq2),
    mq(q_len),
    mq2(q_len),
    rq(q_len)
{   /* nothing */
}

susan::~susan(void)
{   /* nothing */
}

#line 96 "./susan.sc"
void susan::main(void) {

#line 104 "./susan.sc"
    { _specc::fork _scc_fork_0(&D), _scc_fork_1(&S), _scc_fork_2(&E); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }
}

#line 1301 "design.cc"
stimulus::stimulus(unsigned int _idcnt, i_sender (&start), unsigned char (&in_sc)[7220], char (&filename)[200])
    : _specc::behavior(_idcnt), start(start), in_sc(in_sc), filename(filename),
    counter(0u),
    g(_IDcnt, start, in_sc, filename)
{   /* nothing */
}

stimulus::~stimulus(void)
{   /* nothing */
}

#line 118 "./susan.sc"
void stimulus::main(void) {
    _specc::waitfor(1000);
    for(i = 0; i < 1000; i++ ) {
	g.main();
	_specc::waitfor(500);
    }
    exit(0);
}

#line 1323 "design.cc"
monitor::monitor(unsigned int _idcnt, i_receiver (&rec), char (&filename)[200])
    : _specc::behavior(_idcnt), rec(rec), filename(filename),
    p(_IDcnt, rec, filename)
{   /* nothing */
}

monitor::~monitor(void)
{   /* nothing */
}

#line 130 "./susan.sc"
void monitor::main(void) {
    { enum { _scc_state_0, _scc_state_p } _scc_next_state = _scc_state_p; do switch(_scc_next_state) {
	    case _scc_state_p: { p.main(); { _scc_next_state = _scc_state_p; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 1341 "design.cc"
WriteImage::WriteImage(unsigned int _idcnt, i_in_receiver (&rec), i_sender (&sd))
    : _specc::behavior(_idcnt), rec(rec), sd(sd)
{   /* nothing */
}

WriteImage::~WriteImage(void)
{   /* nothing */
}

#line 20 "./write_image.sc"
void WriteImage::main(void)
{   
    unsigned int i;
    while(1) {
	for(i = 0; i < 7220; i++ ) {
	    rec.receive(out_sc + i);
	}




	sd.send(out_sc, 76 * 95 * sizeof(unsigned char));
    }
}

#line 1367 "design.cc"
Design::Design(unsigned int _idcnt, i_receiver (&start), unsigned char (&image_buffer)[7220], i_sender (&sd))
    : _specc::behavior(_idcnt), start(start), image_buffer(image_buffer), sd(sd),
    SIZE(7220ul),
    q_len(7220ul),
    R(++_IDcnt, start, image_buffer, buffer_in_d, buffer_in_e),
    S(++_IDcnt, buffer_in_d, buffer_in_e, buffer_out),
    W(++_IDcnt, buffer_out, sd),
    buffer_in_d(q_len),
    buffer_in_e(q_len),
    buffer_out(q_len)
{   /* nothing */
}

Design::~Design(void)
{   /* nothing */
}

#line 53 "design.sc"
void Design::main(void) {
    { _specc::fork _scc_fork_0(&R), _scc_fork_1(&S), _scc_fork_2(&W); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }
}

#line 1394 "design.cc"
Main::Main(unsigned int _idcnt)
    : _specc::class_type(_idcnt),
    d(_IDcnt, start, image_buffer, end),
    end(),
    mon(_IDcnt, end, outputfile),
    start(),
    sti(_IDcnt, start, image_buffer, inputfile)
{   
    char _scc_init_inputfile[200] = 

#line 66 "design.sc"
    "input_small.pgm";
    
    {   unsigned int _scc_index_0;
	for(_scc_index_0 = 0; _scc_index_0 < 200; _scc_index_0++)
	    inputfile[_scc_index_0] = _scc_init_inputfile[_scc_index_0];
    }
    char _scc_init_outputfile[200] = 

#line 67 "design.sc"
    "output_edge.pgm";
    
    {   unsigned int _scc_index_0;
	for(_scc_index_0 = 0; _scc_index_0 < 200; _scc_index_0++)
	    outputfile[_scc_index_0] = _scc_init_outputfile[_scc_index_0];
    }
}

#line 1423 "design.cc"
Main::~Main(void)
{   /* nothing */
}

#line 75 "design.sc"
int Main::main(void) {
    { _specc::fork _scc_fork_0(&sti), _scc_fork_1(&d), _scc_fork_2(&mon); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }
    return 0;
}

#line 1438 "design.cc"
Main _scc_main(_IDcnt);

int main(void)
{   
    int _scc_main_return;
    
    _specc::start();
    _scc_main_return = _scc_main.main();
    _specc::end();
    return(_scc_main_return);
}

void _scc_bit4_err_handle(
    const _bit4& bit4vec)
{   
    char temp_bits[1024], *p;
    p=bit2str(2,&temp_bits[1023], bit4vec);
    _specc::abort(
	"ERROR:\t Casting a bit4 vector failed \n"
	"Bit4 vector contains X/Z values %s\n"
	"Simulation aborted.\n", p);
	
}

//////////////////////////////////////////////////////////////////////
// End of file design.cc
//////////////////////////////////////////////////////////////////////
